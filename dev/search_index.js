var documenterSearchIndex = {"docs":
[{"location":"functions/#","page":"Function list","title":"Function list","text":"Pages   = [\"API.md\"]","category":"page"},{"location":"contribute/#Contributors-Guide-1","page":"Contributing","title":"Contributors Guide","text":"","category":"section"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Contributions of any kind are very welcome! Bessels.jl is a community-driven project and is under the JuliaMath organization. If you are interested in getting involved with the development of Bessels.jl please feel free to open an issue. In general, contributions will likely fall under four main categories:","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"1. Implementing a new function","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Any Bessel type or related function is welcome for inclusion in this library. Please read the scope section for more details but in general any function listed here would be a good addition. Opening an issue would be a great start to further discuss a particular function or implementation details. If you already have an existing function ready to go please open a pull request. Porting functions from MIT compatible implementation is also acceptable.","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"In general, Bessels.jl aims to provide highly accurate implementations. We do not have a set error tolerance we are willing to accept as it will depend on the function. For example, the gamma function is a very important and widely used function so it is necessary to provide maximal errors less than 2 Units in the last place (ULP). For other functions, such as the Bessel function, which oscillate around zero it is much more difficult to provide such tight error tolerances. Therefore, relative tolerances better than 1e-14 would be a good target with a slightly less tolerance around the zeros. Single variable functions should be able to provide better tolerances than multi-variable functions.","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Even if the function isn't quite to those error tolerances, please open a pull request to discuss further. It might be good for a single precision implementation or there might be opportunities to improve the errors of the existing implementation. Though, there are fairly strict criteria that the function should be non-allocating and type stable.","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"2. Improving exisiting function","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Improving the accuracy or speed of any implementation would be a great contribution. There are plenty of opportunities so please open an issue if you are interested and we can point you to a good function to work with. Accuracy improvements are always welcome whereas any speed improvements would also need to maintain the current level of accuracy. Ideally, implementations could trend to more accurate and faster but there will always be some tradeoff.","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"3. Filing bug reports, writing tests, feature requests, improve documentation","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Testing the accuracy and performance of each function is also welcome. In the future, we hope to have an automated way to print out the error and performance of each function so any help with this would be appreciated. Additionally, contributing better tests and writing documentation is very helpful. Filing feature requests are also very helpful.","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"4. Other miscellaneous contributions","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Please also share any papers or discussions on implementation details!","category":"page"},{"location":"contribute/#Pull-Requests-1","page":"Contributing","title":"Pull Requests","text":"","category":"section"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Contributions should be made via pull requests on GitHub. This can be done by forking Bessels.jl and making commits on your own fork. After you have made all necessary changes please submit a pull request against the main branch. We will then review and provide any feedback on the changes. Once you a submit a PR, the automated tests will run through CI. Therefore, please also include tests if you are implementing a new function and review the results of the CI run. We typically keep all tests passing on the main branch, so any CI failures are most likely related to the PR. By submitting a pull request, you are agreeing for contributed code to be under the MIT license.","category":"page"},{"location":"contribute/#","page":"Contributing","title":"Contributing","text":"Code Style: There is not an explicit code style that we use. Please try to keep it as consistent as possible with existing code.","category":"page"},{"location":"roadmap/#Bessels.jl-Roadmap-1","page":"Roadmap","title":"Bessels.jl Roadmap","text":"","category":"section"},{"location":"roadmap/#","page":"Roadmap","title":"Roadmap","text":"The major development goals can be summarized by the following groups.","category":"page"},{"location":"roadmap/#Support-for-complex-arguments-1","page":"Roadmap","title":"Support for complex arguments","text":"","category":"section"},{"location":"roadmap/#","page":"Roadmap","title":"Roadmap","text":"The current development and immediate goals of this project is to provide support for complex variables in all the existing functions. Currently, the Airy functions airyai, airyaiprime, airybi, and airybiprime are the only supported functions using complex variables. This will be implemented in a step approach focusing on single argument functions with fixed order (e.g. nu=0 1) then expanded to the general case of arbitrary order. Therefore, current focus is on developing complex routines for besselj0(z), besselj1(z), bessely0(z), bessely1(z), besselk0(z), besselk1(z), besseli0(z), and besseli1(z).","category":"page"},{"location":"roadmap/#Adding-additional-special-functions-1","page":"Roadmap","title":"Adding additional special functions","text":"","category":"section"},{"location":"roadmap/#","page":"Roadmap","title":"Roadmap","text":"A nice list of Bessel and related functions is provided by mpmath. Any function listed there would be a good candidate for inclusion in this package. Functions on the current scope are the Kelvin, Struve, and Scorer type functions. If other functions (or the ones listed) are desired, please open an issue!","category":"page"},{"location":"roadmap/#Develop-higher-precision-routines-1","page":"Roadmap","title":"Develop higher precision routines","text":"","category":"section"},{"location":"roadmap/#","page":"Roadmap","title":"Roadmap","text":"Current development has focused on single and double precison routine (Float32 and Float64). We intend to also provide support for higher precision types such as double-double (Double64) and/or quadruple  (Float128) precision in the future. ","category":"page"},{"location":"roadmap/#Derivatives-through-automatic-differentiation-1","page":"Roadmap","title":"Derivatives through automatic differentiation","text":"","category":"section"},{"location":"roadmap/#","page":"Roadmap","title":"Roadmap","text":"Typically, the derivatives of certain special functions with respect to argument can be obtained through definitions. However, derivative with respect to the order usually does not have a simple expression. Automatic differentiation could be a powerful tool to quickly compute higher order derivatives using native Julia code. This is not an immediate goal but would be a welcome contribution.","category":"page"},{"location":"roadmap/#Accuracy-and-Peformance-improvements-1","page":"Roadmap","title":"Accuracy and Peformance improvements","text":"","category":"section"},{"location":"roadmap/#","page":"Roadmap","title":"Roadmap","text":"Speed improvements are beneficial in most cases as these low level functions are typically called many times. Performance gains can come from using better algorithms or through better support for parallelization (e.g., vectorization, SIMD). In general, any speed improvements will only be incoporated that maintain the current relative accuracy. Accuracy improvements may come at the cost of a slightly longer runtime. These type of improvements will come on a more ad-hoc basis.","category":"page"},{"location":"install/#Installation-requirements-1","page":"Getting started","title":"Installation requirements","text":"","category":"section"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"Bessels requires Julia v1.6 or later but it is recommended to use the latest stable release. Bessels uses CI tools provided by GitHub Actions to run tests on Julia versions 1.6, current stable release, and nightly builds on Linux operating systems using ubuntu-latest. Though, Bessels is written entirely in Julia and therefore should work on any of the supported platforms such as MacOS and Windows.","category":"page"},{"location":"install/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"Install Julia by downloading the latest version from the offical site and follow the platform specific installations. ","category":"page"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"You can add Bessels using Julia's package manager by typing ] add Bessels in the Julia prompt.","category":"page"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"julia> ] # ']' should be pressed\n\n(@v1.8) pkg> add Bessels","category":"page"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"The package manager can also be used verify the installation by running the bundled tests, check the installed version, or update to the latest release.","category":"page"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"julia> ]\n\n# run tests\n(@v1.8) pkg> test Bessels\n\n# check version\n(@v1.8) pkg> status Bessels\nStatus `~/.julia/environments/v1.8/Project.toml`\n  [0e736298] Bessels v0.2.7\n\n# update to latest release\n(@v1.8) pkg> update Bessels","category":"page"},{"location":"install/#Running-1","page":"Getting started","title":"Running","text":"","category":"section"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"At this point you are ready to start using Bessels.jl!","category":"page"},{"location":"install/#","page":"Getting started","title":"Getting started","text":"julia> using Bessels\n\njulia> besselj0(1.2)\n0.6711327442643626\n\njulia> besselj(1.8, 10.1)\n0.2374319718222891","category":"page"},{"location":"#Bessels.jl-1","page":"Home","title":"Bessels.jl","text":"","category":"section"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Bessels.jl is a collection of mathematical algorithms to compute special functions written entirely in the Julia programming language. It is focused on providing high quality implementations of mathematical functions that are accurate and highly performant. Since it contains only Julia code and has no external dependencies, it is a lightweight package that can be used in any high performance application while taking advatnage of the dynamism of the Julia language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Bessels.jl contains numerous definitions of special functions important in many fields of mathematical physics. Available functions include Bessel, Modified Bessel, Spherical Bessel, Airy, Hankel, and Gamma functions. A full list of availabe functions can be found in the API section of this documentation. Initial development has focused on providing implementations for real arguments, however, some functions (e.g., Airy) also accept complex numbers as input.","category":"page"},{"location":"#Scope-1","page":"Home","title":"Scope","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Bessels.jl started simply as a package to compute just the Bessel function of the first kind and zero order, but it has quickly grown to include several Bessel type functions. As mentioned earlier, Bessels.jl contains algorithms for computing Bessel, Modified Bessel, Spherical Bessel, Airy, and Hankel functions. These functions are contained in Chapters 9 and 10 of the NIST Digitial Library of Mathematical Functions. However, there exists other types of related functions such as the Struve and Weber type functions contained in Chapters 11 and 12. In general, these are special cases of the confuent hypergeometric functions _0F_1 _1F_1, and _1F_2. Additionally, several other special functions such as the gamma functions are also needed to compute these types of functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Therefore, Bessels.jl seeks to be home to any Bessel or related functions (see the section provided by mpmath) which are typically contained in Chapters 9-12 of the NIST Digital library or to any other related function required to compute Bessel type functions.","category":"page"},{"location":"#Advantages-1","page":"Home","title":"Advantages","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Typically 2-12x faster than other available implementations\nWritten entirely in Julia","category":"page"},{"location":"#Limitations-1","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Does not yet support automatic differentiation\nLimited support for complex arguments\nNo support for higher precision (above Float64)","category":"page"},{"location":"#Packages-using-Bessels.jl-1","page":"Home","title":"Packages using Bessels.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Meshes.jl\nGeoStats.jl\nBesselK.jl\nSparseIR.jl\nVariography.jl\nLightPropagation.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you are using Bessels.jl, please feel free to add yours to the list!","category":"page"},{"location":"#Related-Math-libraries-1","page":"Home","title":"Related Math libraries","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Julia packages","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SpecialFunctions.jl\nHypergeometricFunctions.jl\nClassicalOrthogonalPolynomials.jl\nLegendrePolynomials.jl\nBesselK.jl\nAssociatedLegendrePolynomials.jl\nHarmonicOrthogonalPolynomials.jl\nSphericalHarmonics.jl\nArbNumerics.jl\nElliptic.jl\nEllipticFunctions.jl\nClausenFunctions.jl\nPolylogarithms.jl\nPolyLog.jl\nLambertW.jl\nStruve.jl\nQuadmath.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Other","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SciPy\nmpmath\nArb\nBoost\nGSL\nCephes\nfortran-bessels","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is by no means exhaustive so please add yours or any others that should be listed.","category":"page"},{"location":"API/#Bessel-functions-1","page":"API","title":"Bessel functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"besselj\nBessels.besselj!\nbesselj0\nbesselj1\nbessely\nBessels.bessely!\nbessely0\nbessely1\nBessels.besseljy","category":"page"},{"location":"API/#Bessels.besselj","page":"API","title":"Bessels.besselj","text":"besselj(ν::Real, x::Real)\nbesselj(ν::AbstractRange, x::Real)\n\nReturns the Bessel function, J_ν(x), of the first kind and order ν.\n\nJ_nu(x) = sum_m=0^infty frac(-1)^mmGamma(m+nu+1)(fracx2)^2m+nu\n\nRoutine supports single and double precision (e.g., Float32 or Float64) real arguments.\n\nFor ν isa AbstractRange, returns a vector of type float(x) using recurrence to compute J_ν(x) at many orders as long as the conditions ν[1] >= 0 and step(ν) == 1 are met. Consider the in-place version besselj! to avoid allocation.\n\nExamples\n\njulia> besselj(2, 1.5)\n0.2320876721442147\n\njulia> besselj(3.2, 2.5)\n0.17888479721039752\n\njulia> besselj(1:3, 2.5)\n3-element Vector{Float64}:\n 0.4970941024642743\n 0.44605905843961735\n 0.2166003910391135\n\nExternal links: DLMF, Wikipedia\n\nSee also: besselj!, besselj0(x), besselj1(x)\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselj!","page":"API","title":"Bessels.besselj!","text":"Bessels.besselj!(out::DenseVector{T}, ν::AbstractRange, x::T)\n\nComputes the Bessel function, j_ν(x), of the first kind at many orders ν in-place using recurrence. The conditions ν[1] >= 0 and step(ν) == 1 must be met.\n\nExamples\n\njulia> nu = 1:3; x = 1.5; out = zeros(typeof(x), length(nu));\n\njulia> Bessels.besselj!(out, nu, x)\n3-element Vector{Float64}:\n 0.5579365079100995\n 0.2320876721442147\n 0.06096395114113963\n\nSee also: besselj(ν, x)\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselj0","page":"API","title":"Bessels.besselj0","text":"besselj0(x::T) where T <: Union{Float32, Float64, ComplexF32, ComplexF64}\n\nBessel function of the first kind of order zero, J_0(x).\n\nSee also: besselj1(x), besselj(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselj1","page":"API","title":"Bessels.besselj1","text":"besselj1(x::T) where T <: Union{Float32, Float64, ComplexF32, ComplexF64}\n\nBessel function of the first kind of order one, J_1(x).\n\nSee also: besselj0(x), besselj(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.bessely","page":"API","title":"Bessels.bessely","text":"bessely(ν::Real, x::Real)\nbessely(ν::AbstractRange, x::Real)\n\nReturns the Bessel function, Y_ν(x), of the second kind and order ν.\n\nY_nu(x) = fracJ_nu(x) cos(nu pi) - J_-nu(x)sin(nu pi)\n\nRoutine supports single and double precision (e.g., Float32 or Float64) real arguments.\n\nFor ν isa AbstractRange, returns a vector of type float(x) using recurrence to compute Y_ν(x) at many orders as long as the conditions ν[1] >= 0 and step(ν) == 1 are met. Consider the in-place version besselj! to avoid allocation.\n\nExamples\n\njulia> bessely(2, 1.5)\n-0.9321937597629739\n\njulia> bessely(3.2, 2.5)\n-0.8425784476035085\n\njulia> bessely(1:3, 2.5)\n3-element Vector{Float64}:\n  0.1459181379667858\n -0.38133584924180347\n -0.7560554967536713\n\nExternal links: DLMF, Wikipedia\n\nSee also: bessely!, bessely0(x), bessely1(x)\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.bessely!","page":"API","title":"Bessels.bessely!","text":"Bessels.bessely!(out::DenseVector{T}, ν::AbstractRange, x::T)\n\nComputes the Bessel function, Y_ν(x), of the second kind at many orders ν in-place using recurrence. The conditions ν[1] >= 0 and step(ν) == 1 must be met.\n\nExamples\n\njulia> nu = 1:3; x = 1.5; out = zeros(typeof(x), length(nu));\n\njulia> Bessels.bessely!(out, nu, x)\n3-element Vector{Float64}:\n -0.41230862697391135\n -0.9321937597629739\n -2.0735413990606855\n\nSee also: bessely(ν, x)\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.bessely0","page":"API","title":"Bessels.bessely0","text":"bessely0(x::T) where T <: Union{Float32, Float64}\n\nBessel function of the second kind of order zero, Y_0(x).\n\nSee also: bessely1(x), bessely(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.bessely1","page":"API","title":"Bessels.bessely1","text":"bessely1(x::T) where T <: Union{Float32, Float64}\n\nBessel function of the second kind of order one, Y_1(x).\n\nSee also: bessely0(x), bessely(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besseljy","page":"API","title":"Bessels.besseljy","text":"Bessels.besseljy(ν, x::T) where T <: Float64\n\nReturns the Bessel function of the first J_ν(x) and second Y_ν(x) kind for order ν.\n\nThis method may be faster than calling besselj(ν, x) and bessely(ν, x) separately depending on argument range. Results may be slightly different than calling individual functions in some domains due to using different algorithms.\n\nExamples\n\njulia> jn, yn = Bessels.besseljy(1.8, 1.2)\n(0.2086667754797278, -1.0931173556626879)\n\nSee also: besselh, besselj(nu,x)), bessely(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Modified-Bessel-functions-1","page":"API","title":"Modified Bessel functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"besseli\nBessels.besseli!\nbesseli0\nbesseli0x\nbesseli1\nbesseli1x\nbesselix\nbesselk\nBessels.besselk!\nbesselk0\nbesselk0x\nbesselk1\nbesselk1x\nbesselkx","category":"page"},{"location":"API/#Bessels.besseli","page":"API","title":"Bessels.besseli","text":"besseli(ν::Real, x::Real)\nbesseli(ν::AbstractRange, x::Real)\n\nReturns the modified Bessel function, I_ν(x), of the first kind and order ν.\n\nI_nu(x) = sum_m=0^infty frac1mGamma(m+nu+1)(fracx2)^2m+nu\n\nRoutine supports single and double precision (e.g., Float32 or Float64) real arguments.\n\nFor ν isa AbstractRange, returns a vector of type float(x) using recurrence to compute I_ν(x) at many orders as long as the conditions ν[1] >= 0 and step(ν) == 1 are met. Consider the in-place version besseli! to avoid allocation.\n\nExamples\n\njulia> besseli(2, 1.5)\n0.3378346183356807\n\njulia> besseli(3.2, 2.5)\n0.3772632469352918\n\njulia> besseli(1:3, 2.5)\n3-element Vector{Float64}:\n 2.5167162452886984\n 1.2764661478191641\n 0.47437040877803555\n\nExternal links: DLMF, Wikipedia\n\nSee also: besseli!, besseli0(x), besseli1(x), besselix(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besseli!","page":"API","title":"Bessels.besseli!","text":"Bessels.besseli!(out::DenseVector{T}, ν::AbstractRange, x::T)\n\nComputes the modified Bessel function, I_ν(x), of the first kind at many orders ν in-place using recurrence. The conditions ν[1] >= 0 and step(ν) == 1 must be met.\n\nExamples\n\njulia> nu = 1:3; x = 1.5; out = zeros(typeof(x), length(nu));\n\njulia> Bessels.besseli!(out, nu, x)\n3-element Vector{Float64}:\n 0.9816664285779074\n 0.3378346183356807\n 0.0807741130160923\n\nSee also: besseli(ν, x)\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besseli0","page":"API","title":"Bessels.besseli0","text":"besseli0(x::T) where T <: Union{Float32, Float64, ComplexF32, ComplexF64}\n\nModified Bessel function of the first kind of order zero, I_0(x).\n\nSee also: besseli0x(x), besseli1(x), besseli(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besseli0x","page":"API","title":"Bessels.besseli0x","text":"besseli0x(x::T) where T <: Union{Float32, Float64}\n\nScaled modified Bessel function of the first kind of order zero, I_0(x)*e^-x.\n\nSee also: besseli0(x), besseli1x(x), besseli(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besseli1","page":"API","title":"Bessels.besseli1","text":"besseli1(x::T) where T <: Union{Float32, Float64, ComplexF32, ComplexF64}\n\nModified Bessel function of the first kind of order one, I_1(x).\n\nSee also: besseli0(x), besseli1x(x), besseli(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besseli1x","page":"API","title":"Bessels.besseli1x","text":"besseli1x(x::T) where T <: Union{Float32, Float64}\n\nScaled modified Bessel function of the first kind of order one, I_1(x)*e^-x.\n\nSee also: besseli1(x), besseli(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselix","page":"API","title":"Bessels.besselix","text":"besselix(nu, x::T) where T <: Union{Float32, Float64}\n\nScaled modified Bessel function of the first kind of order nu, I_nu(x)*e^-x. Nu must be real.\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselk","page":"API","title":"Bessels.besselk","text":"besselk(ν::Real, x::Real)\nbesselk(ν::AbstractRange, x::Real)\n\nReturns the modified Bessel function, K_ν(x), of the second kind and order ν.\n\nK_nu(x) = fracpi2 fracI_-nu(x) - I_nu(x)sin(nu pi)\n\nRoutine supports single and double precision (e.g., Float32 or Float64) real arguments.\n\nFor ν isa AbstractRange, returns a vector of type float(x) using recurrence to compute K_ν(x) at many orders as long as the conditions ν[1] >= 0 and step(ν) == 1 are met. Consider the in-place version besselk! to avoid allocation.\n\nExamples\n\njulia> besselk(2, 1.5)\n0.5836559632566508\n\njulia> besselk(3.2, 2.5)\n0.3244950563641161\n\njulia> besselk(1:3, 2.5)\n3-element Vector{Float64}:\n 0.07389081634774707\n 0.12146020627856384\n 0.26822714639344925\n\nExternal links: DLMF, Wikipedia\n\nSee also: besselk!, besselk0(x), besselk1(x), besselkx(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselk!","page":"API","title":"Bessels.besselk!","text":"Bessels.besselk!(out::DenseVector{T}, ν::AbstractRange, x::T)\n\nComputes the modified Bessel function, K_ν(x), of the second kind at many orders ν in-place using recurrence. The conditions ν[1] >= 0 and step(ν) == 1 must be met.\n\nExamples\n\njulia> nu = 1:3; x = 1.5; out = zeros(typeof(x), length(nu));\n\njulia> Bessels.besselk!(out, nu, x)\n3-element Vector{Float64}:\n 0.2773878004568438\n 0.5836559632566508\n 1.8338037024745792\n\nSee also: besselk(ν, x)\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselk0","page":"API","title":"Bessels.besselk0","text":"besselk0(x::T) where T <: Union{Float32, Float64}\n\nModified Bessel function of the second kind of order zero, K_0(x).\n\nSee also: besselk0x(x), besselk1(x), besselk(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselk0x","page":"API","title":"Bessels.besselk0x","text":"besselk0x(x::T) where T <: Union{Float32, Float64}\n\nScaled modified Bessel function of the second kind of order zero, K_0(x)*e^x.\n\nSee also: besselk0(x), besselk1x(x), besselk(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselk1","page":"API","title":"Bessels.besselk1","text":"besselk1(x::T) where T <: Union{Float32, Float64}\n\nModified Bessel function of the second kind of order one, K_1(x).\n\nSee also: besselk0(x), besselk1x(x), besselk(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselk1x","page":"API","title":"Bessels.besselk1x","text":"besselk1x(x::T) where T <: Union{Float32, Float64}\n\nScaled modified Bessel function of the second kind of order one, K_1(x)*e^x.\n\nSee also: besselk1(x), besselk(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.besselkx","page":"API","title":"Bessels.besselkx","text":"besselkx(x::T) where T <: Union{Float32, Float64}\n\nScaled modified Bessel function of the second kind of order nu, K_nu(x)*e^x.\n\n\n\n\n\n","category":"function"},{"location":"API/#Hankel-functions-1","page":"API","title":"Hankel functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"besselh\nhankelh1\nhankelh2","category":"page"},{"location":"API/#Bessels.besselh","page":"API","title":"Bessels.besselh","text":"besselh(nu, [k=1,] x)\n\nReturns the Bessel function of the third kind of order nu (the Hankel function).\n\nH^(1)_nu(x) = J_nu(x) + i Y_nu(x)\nH^(2)_nu(x) = J_nu(x) - i Y_nu(x)\n\nk must be 1 or 2, selecting hankelh1 or hankelh2, respectively.\n\nExamples\n\njulia> besselh(1.2, 1, 9.2)\n0.2513215427211038 + 0.08073652619125624im\n\nSee also: Bessels.besseljy, besselj(nu,x)), bessely(nu,x))\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.hankelh1","page":"API","title":"Bessels.hankelh1","text":"hankelh1(nu, x)\n\nBessel function of the third kind of order nu, H^(1)_nu(x).\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.hankelh2","page":"API","title":"Bessels.hankelh2","text":"hankelh2(nu, x)\n\nBessel function of the third kind of order nu, H^(2)_nu(x).\n\n\n\n\n\n","category":"function"},{"location":"API/#Spherical-Bessel-functions-1","page":"API","title":"Spherical Bessel functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"sphericalbesselj\nsphericalbessely\nBessels.sphericalbesseli\nBessels.sphericalbesselk","category":"page"},{"location":"API/#Bessels.sphericalbesselj","page":"API","title":"Bessels.sphericalbesselj","text":"sphericalbesselj(ν, x)\n\nSpherical bessel function of the first kind of order ν, j_ν(x). This is the non-singular solution to the radial part of the Helmholz equation in spherical coordinates.\n\nj_nu(x) = sqrt(fracpi2x) J_nu + 12(x)\n\nwhere J_nu is the Bessel function of the first kind. Routine supports single and double precision (e.g., Float32,  Float64) for real arguments.\n\nExamples\n\njulia> sphericalbesselj(1, 1.2)\n0.34528456985779027\n\njulia> sphericalbesselj(1.5, 1.2)\n0.18231344932382995\n\nExternal links: DLMF, Wikipedia\n\nSee also: besselj, sphericalbessely\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.sphericalbessely","page":"API","title":"Bessels.sphericalbessely","text":"sphericalbessely(ν, x)\n\nSpherical bessel function of the second kind of order ν, y_ν(x). This is the non-singular solution to the radial part of the Helmholz equation in spherical coordinates. Sometimes known as a spherical Neumann function.\n\ny_nu(x) = sqrt(fracpi2x) Y_nu + 12(x)\n\nwhere Y_nu is the Bessel function of the second kind. Routine supports single and double precision (e.g., Float32,  Float64) for real arguments.\n\nExamples\n\njulia> sphericalbessely(1, 1.2)\n-1.028336567803712\n\njulia> sphericalbessely(1.5, 1.2)\n-1.4453716277410136\n\nExternal links: DLMF, Wikipedia\n\nSee also: bessely, sphericalbesselj\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.sphericalbesseli","page":"API","title":"Bessels.sphericalbesseli","text":"Bessels.sphericalbesseli(ν, x)\n\nReturns the modified spherical bessel function of the first kind of order ν, i_ν(x).\n\ni_nu(x) = sqrt(fracpi2x) I_nu + 12(x)\n\nwhere I_nu is the modified Bessel function of the first kind. Routine supports single and double precision (e.g., Float32,  Float64) for real arguments.\n\nExamples\n\njulia> Bessels.sphericalbesseli(1, 1.2)\n0.4606425870674146\n\njulia> Bessels.sphericalbesseli(1.5, 1.2)\n0.23179256391926525\n\nExternal links: DLMF, Wikipedia\n\nSee also: besseli, Bessels.sphericalbesselk\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.sphericalbesselk","page":"API","title":"Bessels.sphericalbesselk","text":"Bessels.sphericalbesselk(ν, x)\n\nReturns the modified spherical bessel function of the second kind of order ν, k_ν(x).\n\nk_nu(x) = sqrt(fracpi2x) K_nu + 12(x)\n\nwhere K_nu is the modified Bessel function of the second kind. Routine supports single and double precision (e.g., Float32,  Float64) for real arguments.\n\nExamples\n\njulia> Bessels.sphericalbesselk(1, 1.2)\n0.46015782375475334\n\njulia> Bessels.sphericalbesselk(1.5, 1.2)\n0.7595606983594666\n\nExternal links: DLMF, Wikipedia\n\nSee also: besselk, Bessels.sphericalbesseli\n\n\n\n\n\n","category":"function"},{"location":"API/#Airy-functions-1","page":"API","title":"Airy functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"airyai\nairyaiprime\nairybi\nairybiprime","category":"page"},{"location":"API/#Bessels.airyai","page":"API","title":"Bessels.airyai","text":"airyai(z)\n\nReturns the Airy function of the first kind, operatornameAi(z), which is the solution to the Airy differential equation f(z) - z f(z) = 0.\n\noperatornameAi(z) = fracsqrt32 pi int_0^^infty exp-fract^33 - fracz^33t^3 dt\n\nRoutine supports single and double precision (e.g., Float32,  Float64, ComplexF64) for real and complex arguments.\n\nExamples\n\njulia> airyai(1.2)\n0.10612576226331255\n\njulia> airyai(1.2 + 1.4im)\n-0.03254458873613304 - 0.14708163733976673im\n\nExternal links: DLMF, Wikipedia\n\nSee also: airyaiprime, airybi\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.airyaiprime","page":"API","title":"Bessels.airyaiprime","text":"airyaiprime(z)\n\nReturns the derivative of the Airy function of the first kind, 1\\operatorname{Ai}'(z). Routine supports single and double precision (e.g.,Float32,Float64,ComplexF64`) for real and complex arguments.\n\nExamples\n\njulia> airyaiprime(1.2)\n-0.13278537855722622\n\njulia> airyaiprime(1.2 + 1.4im)\n-0.02884977394212135 + 0.21117856532576215im\n\nExternal links: DLMF, Wikipedia\n\nSee also: airyai, airybi\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.airybi","page":"API","title":"Bessels.airybi","text":"airybi(z)\n\nReturns the Airy function of the second kind, operatornameBi(z), which is the second solution to the Airy differential equation f(z) - z f(z) = 0. Routine supports single and double precision (e.g., Float32,  Float64, ComplexF64) for real and complex arguments.\n\nExamples\n\njulia> airybi(1.2)\n1.4211336756103483\n\njulia> airybi(1.2 + 1.4im)\n0.3150484065220768 + 0.7138432162853446im\n\nExternal links: DLMF, Wikipedia\n\nSee also: airybiprime, airyai\n\n\n\n\n\n","category":"function"},{"location":"API/#Bessels.airybiprime","page":"API","title":"Bessels.airybiprime","text":"airybiprime(z)\n\nReturns the derivative of the Airy function of the second kind, operatornameBi(z). Routine supports single and double precision (e.g., Float32,  Float64, ComplexF64) for real and complex arguments.\n\nExamples\n\njulia> airybiprime(1.2)\n1.221231398704895\n\njulia> airybiprime(1.2 + 1.4im)\n-0.5250248310153249 + 0.9612736841097036im\n\nExternal links: DLMF, Wikipedia\n\nSee also: airybi, airyai\n\n\n\n\n\n","category":"function"},{"location":"API/#Gamma-functions-1","page":"API","title":"Gamma functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"Bessels.gamma","category":"page"},{"location":"API/#Bessels.gamma","page":"API","title":"Bessels.gamma","text":"gamma(x::T) where T <: Union{Float16, Float32, Float64}\n\nReturns the gamma function, Γ(x), for real x.\n\nGamma(x) = int_x^infty e^-t t^x-1 dt \n\nExternal links: DLMF, Wikipedia\n\n\n\n\n\n","category":"function"}]
}
